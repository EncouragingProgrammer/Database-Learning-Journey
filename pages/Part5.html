<html lang="en">
<head>
	<title>Database Management Learning Journey - Part 5</title>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1.0"> 
	<link rel="stylesheet" href="../css/style.css" />
</head>

<body>
    <header><h1><a href="../index.html">Intro to Database Management</a></h1></header>

	<h2>Unit 5 Section 1: SQL as a Data Definition Language (DDL)</h2>

    <h3>Lecture 5 by Daniel Gaudreault</h3>

    <iframe width="560" height="315" src="https://www.youtube.com/embed/MggWgy0dABY?start=106" 
    title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; 
    encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

    <p>
        <h3>Supplemental SQL / Database courses</h3>
        <p>
            I highly recommend the following LinkedIn Learning courses:
        </p>
        <ul>
            <li>
                <a href="https://www.linkedin.com/learning/sql-essential-training-3/">
                    LinkedIn Learning Course - SQL Essential Training</a> by <a href="https://bw.org/">Bill Weinmann</a>
                <p>
                    This courses focuses on the SQL language and is very beneficial for supplementing this chapter
                    of the textbook.
                </p>
            </li>
            <li>
                <a href="https://www.linkedin.com/learning/database-foundations-intro-to-databases/">LinkedIn
                    Learning Course - Database Foundations: Intro to Databases</a> by <a href="https://adamwilbert.com/">
                        Adam Wilbert</a>
                <p>
                    This course demonstrates using Microsoft SQL Server and PostgreSQL through docker containers,
                    and the Azure Data Studio RDBMS.
                </p>       
            </li>
        </ul>

    </p>

    <h4>Benefits of a Standardized Relational Language</h4>
    <ul>
        <li>Reduced training costs</li>
        <li>Productivity</li>
        <li>Application portability</li>
        <li>Application longevity</li>
        <li>Reduced dependence on a single vendor</li>
        <li>Cross-system communication</li>
    </ul>

    <dl>
        <dt>Relational DBMS</dt>
        <dd>
            A database management system that manages data as a collection of tables in which all
            data relationships are represented by common values in related tables.
        </dd>
        <dt>Catalog</dt>
        <dd>
            A set of schemas that, when put together, contitutes a description of a database.
        </dd>
        <dt>Schema</dt>
        <dd>
            A structure that contains descripions of objects created by a user, such as base tables,
            views, and constraints, as part of a database.
        </dd>
        <dt>data definition language (DDL)</dt>
        <dd>
            Commands used to define a database, including those for creating, altering, and dropping
            tables and established constraints.
        </dd>
        <dt>data manipulation language (DML)</dt>
        <dd>
            Commands used to maintain and query a database, including those for updating, inserting,
            modifying and querying data.
        </dd>
        <dt>Data control language (DCL)</dt>
        <dd>
            Commands used to control a database, including those for administering privileges and
            committing (saving) data.
        </dd>
    </dl>

    <p>
        Basic syntax for creating a database using SQL is:
        <pre><code>
            CREATE SCHEMA database_name; AUTHORIZATION owner_user id
        </code></pre>
    </p>

    <h4 class="center">SQL DDL CREATE Commands:</h4>
    <table class="center">
        <tr>
            <td>CREATE SCHEMA</td>
            <td>
                Used to define the portion of a database that a particular user owns. Schemas are 
                dependent on a catalog and contain schema objects, including base tables and views, 
                domains, constraints, assertions, character sets, collations, and so forth.
            </td>
        </tr>
        <tr>
            <td>CREATE TABLE</td>
            <td>
                Defines a new table and its columns. The table may be a base table or a derived table. 
                Tables are dependent on a schema. Derived tables are created by executing a query that 
                uses one or more tables or views.
            </td>
        </tr>
        <tr>
            <td>CREATE VIEW</td>
            <td>
                Defines a logical table from one or more tables or views. Views may not be indexed. 
                There are limitations on updating data through a view. Where views can be updated, 
                those changes can be transferred to the underlying base tables originally referenced 
                to create the view.
            </td>
        </tr>
    </table>
    
    <h2>Unit 5 Section 2: SQL as a Data Maninpulation Language (DML)</h2>

    <p>
        SQL Inserting into a table:
        <pre><code>
            INSERT INTO Customer_T VALUES
            ('Friendship Castle', '123 Unicorn Road', 'FriendshipVille', 'FN', 12345);
        </code></pre>
    </p>

    <p>
        SQL Deteling rows from a table:
        <pre><code>
            DELETE FROM Customer_T
            WHERE CustomerState = 'FN';
        </code></pre>
        <p>
            Note: it is wise to verify with SELECT rows you intend to delete, and check that only desired rows
            are icluded.
        </p>
    </p>

    <p>
        SQL Update:
        <pre><code>
            UPDATE Product_T
            SET ProductStandardPrice = 700
                WHERE ProductID = 7;
        </code></pre>
    </p>

    <p>
        SQL Create Index:
        <pre><code>
            CREATE INDEX Name_IDX ON Customer_T (CustomerName);
        </code></pre>
        SQL Drop Index: 
        <pre><code>
            DROP INDEX Name_IDX;
        </code></pre>
    </p>

    <h4 class="center">Clauses of the SELECT Statement:</h4>
    <table class="center">
        <tr>
            <td>SELECT</td>
            <td>
                Lists the columns (including expressions involving columns) from base tables, derived tables, 
                or views to be projected into the table that will be the result of the command. (That’s the 
                technical way of saying it lists the data you want to display.)
            </td>
        </tr>
        <tr>
            <td>FROM</td>
            <td>
                Identifies the tables, derived tables, or views from which columns will be chosen to appear 
                in the result table and includes the tables, derived tables, or views needed to join tables 
                to process the query.
            </td>
        </tr>
        <tr>
            <td>WHERE</td>
            <td>
                Includes the conditions for row selection within the items in the FROM clause and the conditions 
                between tables, derived tables, or views for joining. Because SQL is considered a set manipulation 
                language, the WHERE clause is important in defining the set of rows being manipulated.
            </td>
        </tr>
    </table>

    <p>
        <strong>Query: </strong>Which products have a standard price of less than $275?
        <pre><code>
            SELECT ProductDescription, ProductStandardPrice
                FROM Product_T
                    WHERE ProductStandardPrice &#60; 275;
        </code></pre>
    </p>

    <p>
        <strong>Query: </strong>How many different items were ordered on order number 1004?
        <pre><code>
            SELECT COUNT (*)
                FROM OrderLine_T
                    WHERE OrderID = 1004;
        </code></pre>
    </p>

    <p>
        <strong>Query: </strong>List product name, finish, and standard price for all desks and all 
        tables that cost more than $300 in the Product table.
        <pre><code>
            SELECT ProductDescription, ProductFinish, ProductStandardPrice
                FROM Product_T
                    WHERE (ProductDescription LIKE ′%Desk′
                        OR ProductDescription LIKE ′%Table′)   
                        AND ProductStandardPrice &#62; 300;
        </code></pre>
    </p>

    <p>
        <strong>Query: </strong>What are the distinct order numbers included in the OrderLine table?
        <pre><code>
            SELECT DISTINCT OrderID
                FROM OrderLine_T;
        </code></pre>
    </p>

    <p>
        <strong>Query: </strong>List all customers who live in warmer states.
        <pre><code>
            SELECT CustomerName, CustomerCity, CustomerState
                FROM OrderLine_T
                    WHERE CustomerState IN ('FL', 'TX', 'CA', 'HI');
        </code></pre>
    </p>

    <h4 class="center">SQL Order By, Group By, and Having</h4>
    <table class="center">
        <tr>
            <td>ORDER BY</td>
            <td>
                Sorts the final results rows in ascending or descending order.
            </td>
        </tr>
        <tr>
            <td>GROUP BY</td>
            <td>
                Groups rows in an intermediate results table where the values in those rows
                are the same for one or more columns.
            </td>
        </tr>
        <tr>
            <td>HAVING</td>
            <td>
                Can only be used following a GROUP BY and acts as a secondary WHERE clause,
                returning only those groups that meet a specific condition.
            </td>
        </tr>
    </table>

    <dl>
        <dt>Scalar aggregate</dt>
        <dd>
            A single value returned from an SQL query that icludes an aggregate function.
        </dd>
        <dt>Vector aggregate</dt>
        <dd>
            Multiple values retured from an SQL query that icludes an aggregate function.
        </dd>
    </dl>

    <p>
        <strong>Query: </strong>Find only states with more than one customer.
        <pre><code>
            SELECT CustomerState, COUNT (CustomerState)
                FROM Customer_T
                    GROUP BY CustomerState
                    HAVING COUNT (CustomerState) &#62; 1;
        </code></pre>
    </p>

    <dl>
        <dt>Base table</dt>
        <dd>
            A table in the relational data model containing the inserted raw data. Base tables
            correspond to the relations that are identified in the database's conceptual
            schema.
        </dd>
        <dt>Virtual table</dt>
        <dd>
            A table constructed automatically as needed by a DBMS. Virtual tables are not
            maintained as real data.
        </dd>
        <dt>Dynamic view</dt>
        <dd>
            A virtual table that is created dynamically upon request by a user. A dynamic view
            is not a temporary table. Rather, its definition is stored in the system catalog,
            and the contents of the view are materialized as a result of an SQL query that uses
            the view. It differs from a materialized view, which may be stored on a disc and 
            refreshed at intervals or when used, depending on the RDBMS.
        </dd>
        <dt>Materialized view</dt>
        <dd>
            Copies or replicas of data, based on SQL queries created in the same manner as
            dynamic views. However, a materialized view exits as a table and thus care must be
            taken to keep it synchronized with its associated base tables.
        </dd>
    </dl>

    <h2>Unit 5 Section 3: Advanced SQL and Data Control Commands</h2>

    <dl>
        <dt>Join</dt>
        <dd>
            A relational operation that causes two tables with a common domain to be combined
            into a single table or view.
        </dd>
        <dt>Equi-join</dt>
        <dd>
            A join in which the joining condition is based on equality between values in the
            common columns. Common columns appear (redundantly) in the result table.
        </dd>
    </dl>

    <p>
        <strong>Query: </strong>What are the customer IDs and names of all customers, along
            with the order IDs or all the orders they have placed?
        <pre><code>
            SELECT Customer_T.CustomerID, Order_T.CustomerID, CustomerName, OrderID
                FROM Customer_T INNER JOIN Order_T USING CustomerID
                    ORDER BY OrderID;
        </code></pre>
    </p>

    <dl>
        <dt>Natural join</dt>
        <dd>
            A join that is the same as an equi-join except that one of the duplicate columns
            is eliminated in the result table.
        </dd>
    </dl>

    <p>
        <strong>Query: </strong>For each customer who has placed an order, what is the customer's
            ID, name, and order number?
        <pre><code>
            SELECT Customer_T.CustomerID, CustomerName, OrderID
                FROM Customer_T NATURAL JOIN Order_T ON Customer_T.CustomerID = Order_T.CustomerID;
        </code></pre>
    </p>

    <dl>
        <dt>Outer join</dt>
        <dd>
            A join in which rows that do not have matching values in common columns are nevertheless
            included in the result table.
        </dd>
    </dl>

    <p>
        <strong>Query: </strong>What are the employee ID and name of each employee and the name of
            his or her supervisor (label the supervisor's name Manager)?
        <pre><code>
            SELECT E.EmployeeID, E.EmployeeName, M.EmployeeName AS Manager
                FROM Employee_T E, Employee_T M
                    WHERE E.EmployeeSupervisor = M.EmployeeID;
        </code></pre>
    </p>

    <p>
        <strong>Query: </strong>What are the names of customers who have placed orders?
        <pre><code>
            SELECT CustomerName
                FROM Customer_T
                    WHERE CustomerID IN
                        (SELECT DISTINCT CustomerID
                         FROM Order_T);
        </code></pre>
    </p>

    <dl>
        <dt>Correlated subquery</dt>
        <dd>
            In SQL, a subquery in which processing the inner query depends on data from the
            outer query.
        </dd>
    </dl>

    <p>
        <strong>Query: </strong>Show the product description, product standard price, and overall
        average standard price for all products that have a standard price that is higher than the
        average standard price.
       <pre><code>
            SELECT ProductDescription, ProductStandardPrice, AvgPrice
                FROM (SELECT AVG(ProductStandardPrice) AvgPrice FROM Product_T), Product_T
                    WHERE ProductStandardPrice > AvgPrice;
        </code></pre>
    </p>

    <p>
        <strong>Query: </strong>Who is the owner of the PRODUCT_T table?
        <pre><code>
            SELECT OWNER, TABLE_NAME
                FROM DBA_TABLES
                    WHERE TABLE_NAME = 'PRODUCT_T';
        </code></pre>
    </p>

    <dl>
        <dt>User-defined data type (UDT)</dt>
        <dd>
            A data type that a user can define by making it a subclass of a standard type or creating
            a type that behaves as an object. UDTs may also have defined functions and methods.
        </dd>
    </dl>

    <h4 class="center">Some Built-in Functions Added in SQL:200n</h4>
    <table class="center">
        <tr>
            <th>Function</th>
            <th>Descripion</th>
        </tr>
        <tr>
            <td>CEILING</td>
            <td>
                Computes the least integer greater than or equal to its argument - for example,
                CEIL(100) or CEILING(100).
            </td>
        </tr>
        <tr>
            <td>FLOOR</td>
            <td>
                Computes the greatest integer less than or equal to its argument — for example, FLOOR(25).
            </td>
        </tr>
        <tr>
            <td>SQRT</td>
            <td>
                Computes the square root of its argument — for example, SQRT(36).
            </td>
        </tr>
        <tr>
            <td>RANK</td>
            <td>
                Computes the ordinal rank of a row within its window. Implies that if duplicates exist, 
                there will be gaps in the ranks assigned. The rank of the row is defined as 1 plus the 
                number of rows preceding the row that are not peers of the row being ranked.
            </td>
        </tr>
        <tr>
            <td>DENSE_RANK</td>
            <td>
                Computes the ordinal rank of a row within its window. Implies that if duplicates exist, 
                there will be no gaps in the ranks assigned. The rank of the row is the number of distinct 
                rows preceding the row and itself.
            </td>
        </tr>
        <tr>
            <td>ROLLUP</td>
            <td>
                Works with GROUP BY to compute aggregate values for each level of the hierarchy specified 
                by the group by columns, (The hierarchy is assumed to be left to right in the list of GROUP 
                BY columns.)
            </td>
        </tr>
        <tr>
            <td>CUBE</td>
            <td>
                Works with GROUP BY to create a subtotal of all possible columns for the aggregate specified.
            </td>
        </tr>
        <tr>
            <td>SAMPLE</td>
            <td>
                Reduces the number of rows by returning one or more random samples (with or without replacement). 
                (This function is not ANSI SQL-2003 compliant but is available with many RDBMSs.)
            </td>
        </tr>
        <tr>
            <td>OVER or WINDOW</td>
            <td>
                Creates partitions of data, based on values of one or more columns over which other analytical 
                functions (e.g., RANK) can be computed.
            </td>
        </tr>
    </table>

    <dl>
        <dt>Persistent Stored Modules (SQL/PSM)</dt>
        <dd>
            Extensions defined in SQL:1999 that include the capability to create and drop modules of code
            stored in the database schema across user sessions.
        </dd>
    </dl>

    <h4 class="center">SQL/PSM control statements</h4>
    <table class="center">
        <tr>
            <th>Statement</th>
            <th>Descripion</th>
        </tr>
        <tr>
            <td>CASE</td>
            <td>
                Executes different sets of SQL sequences, according to a comparison of values or the value 
                of a WHEN clause, using either search conditions or value expressions. The logic is similar 
                to that of an SQL CASE expression, but it ends with END CASE rather than END and has no 
                equivalent to the ELSE NULL clause.
            </td>
        </tr>
        <tr>
            <td>IF</td>
            <td>
                If a predicate is TRUE, executes an SQL statement. The statement ends with an ENDIF and 
                contains ELSE and ELSEIF statements to manage flow control for different conditions.
            </td>
        </tr>
        <tr>
            <td>LOOP</td>
            <td>
                Causes a statement to be executed repeatedly until a condition exists that results in an exit.
            </td>
        </tr>
        <tr>
            <td>LEAVE</td>
            <td>
                Sets a condition that results in exiting a loop.
            </td>
        </tr>
        <tr>
            <td>FOR</td>
            <td>
                Executes once for each row of a result set.
            </td>
        </tr>
        <tr>
            <td>WHILE</td>
            <td>
                Executes as long as a particular condition exists. Incorporates logic that functions as a 
                LEAVE statement.
            </td>
        </tr>
        <tr>
            <td>REPEAT</td>
            <td>
                Similar to the WHILE statement, but tests the condition after execution of the SQL statement.
            </td>
        </tr>
        <tr>
            <td>ITERATE</td>
            <td>
                Restarts a loop.
            </td>
        </tr>

        </tr>
    </table>

    <dl>
        <dt>Triggers</dt>
        <dd>
            A named set of SQL statements that are considered (triggered) when a data modification (i.e., 
            INSERT, UPDATE, DELETE) occurs or if certain data definitions are encountered. If a condition
            stated within a trigger is met, then a prescribed action is taken.
        </dd>
    </dl>

    <p>
        <strong>Trigger example</strong>
        <pre><code>
            CREATE TRIGGER StandardPriceUpdate
            AFTER UPDATE OF ProductStandardPrice ON Product_T
            FOR EACH ROW
            INSERT INTO PriceUpdates_T VALUES (ProductDescription, SYSDATE, ProductStandardPrice)
        </code></pre>
    </p>

    <p>
        <strong>Trigger example: Safety check</strong>
        <pre><code>
            CREATE TRIGGER Satefy
            ON DATABASE
            FOR DROP_TABLE, ALTER_TABLE
            AS
                PRINT 'You must disable Trigger "safety" to drop or alter tables!'
                ROLLBACK;
        </code></pre>
    </p>

    <dl>
        <dt>Function</dt>
        <dd>
            A stored subroutine that returns one value and has only input parameters.
        </dd>
        <dt>Procedure</dt>
        <dd>
            A collection of procedural and SQL statements that are assigned a unique name within
            the schema and stored in the database.
        </dd>
        <dt>Embedded SQL</dt>
        <dd>
            Hard-coded SQL statements included in a program written in another language, such as
            C or Java.
        </dd>
        <dt>Dynamic SQL</dt>
        <dd>
            Specific SQL code generated on the fly while an application is processing.
        </dd>
    </dl>

    <p>
        <strong>SQL Example from above lecture</strong>
        <pre><code>
            SELECT COUNT(name) AS name_count, city
            FROM customers
            WHERE name LIKE '%a'
            GROUP BY city
            HAVING COUNT(name) > 2
            ORDER BY name_count DESC
        </code></pre>
    </p>

    <footer><a href="../pages/Citations.html">Citations</a></footer>
</body>